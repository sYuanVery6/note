## Base

### Java

------

#### 语言基础

1. `环境` **JDK和JRE区别？**

> * JDK：Java Development Kit的简称，java开发工具包，提供了java的开发环境和运行环境
> * JRE：Java Runtime Environment的简称，java的运行环境，为java的运行提供了所需环境
>
> 具体来说JDK包含JRE，同时还包含了编译Java源码的编译器javac以及一些java程序调试和分析的工具。
>
> ##### 实际案例
>
> 1. 503数管项目中，实现客户端选择本地文件上传到服务器上的程序，在部署过程中，就是在每个客户端部署了一个JRE和Tomcat

2. `内存地址` `对象引用` == 和equals的区别是什么？

> * == 解读
>   * 基本类型：比较的是值是否相同
>   * 引用类型：比较的是引用地址是否相同
> * equals 解读
>   * equals是Object的内置方法，本质上就是 == ，类可以重写equals的equals方法，来自定义两个对象的比较

3. `对象引用` `hashcode` **两个对象的hashCode()相同，则equals也一定为true，对吗？**

> 不对，两个对象的hashCode()相同，equals不一定为true
>
> ##### 个人理解
>
> 从Object角度看，JVM每new一个Object，他都会将这个Object丢到一个Hash表中去，这样的话，下次做Object的比较或者取这个对象的时候，它会根据对象的hashCode再从Hash表取这个对象。这样做的目的是提高取对象的效率
>
> 改写equals时总是要改写hashCode

4. `java关键字` **final在java中有什么作用？**

> * final修饰的类叫最终类，该类不可被继承
> * final修饰的方法不能被重写
> * final修饰的变量叫常量，常量必须被初始化，初始化之后值就不能被修改
> * 被final修饰的常量，在编译阶段会存入常量池中
> * 被final修饰的方法，JVM会尝试将其内联，以提高运行效率

5. `java类型` `String` String属于基础的数据类型吗？

> String 不属于基础类型，String是java封装的字符串类型，底层是一个不可变char类型的数组

6. `java类型` `String` **String常用方法？**

> * equals：比较内容
> * length：获取长度
> * indexOf(String str):获取str在字符串对象中第一次出现的索引
> * subString
> * trim：去除两端空格
> * split：通过某个字符分隔，返回一个分割后的字符串数组
> * 大小写转换、开始结尾判断、判空...

7. `java类型` `String` **java中操作字符串都有哪些类？它们之间有什么区别？**

> 操作字符串的类有String、StringBuilder、StringBuffer
>
> 区别：
>
> * String和StringBuffer、StringBuilder的区别在于String声明的对象时不可变的对象，每次操作都会生成一个新的String对象，然后将指针指向新的String对象，而StringBuilder和StringBuilder可以在原有对象的基础上进行操作，所以在经常改变字符串内容的情况下最高不要使用String。
> * StringBuffer和StringBuilder最大的区别在于，StringBuffer是线程安全的，而StringBuilder是非线程安全的，所以StringBuilder性能高于StringBuilder。

8. `java类型` `String` **String str = "i"与String str = new String("i")一样吗？**

> 不一样，因为内存的分配方式不一样。String str = "i"的方式，java虚拟机会将其分配带常量池中；而通过new声明则会被分到堆内存中。

9.  `抽象类` **抽象类必须要有抽象方法吗?**

> 不需要，抽象类不一定非要有抽象方法

10. `抽象类` **普通类和抽象类有哪些区别？**

> * 普通类不能包含抽象方法，抽象类可以包含抽象方法，抽象方法只需申明，无需实现
> * 抽象类不能直接实例化，普通类可以直接实例化
> * 抽象方法不能生命为静态、不能用private修饰，不能用final修饰

[^date]: 2021-06-07

11. `接口` `抽象类` **接口和抽象类有什么区别？**

> * 实现：子类通过extends来继承抽象类，接口必须使用implements来实现接口
> * 构造函数：抽象类可以有构造函数；接口不能有
> * main方法：抽象类可以有main方法，并且能运行，接口不能有main方法
> * 实现数量：子类只能继承一个抽象类，却可以实现多个接口
> * 访问修饰符：接口中的方法默认使用public修饰；抽象类中的方法可以是任意访问修饰符

12. `IO流` **java中IO流分为几种？**

> 按照功能分：
>
> * 输入流 input
> * 输出流 output
>
> 按照类型分：
>
> * 字节流
> * 字符流
>
> 字节流和字符流的区别：字节流按8位传输以字节为单位输入输出数据，字符流按16位传输以字符为单位输入输出数据
>
> ##### 实际案例
>
> * 在面试过程中出现的频率小，但是在实际项目中却经常用。
> * 访问外部接口下载文件（附件的数据提取功能，网络IO）
> * 卫星数据存档（503数管）
> * 接口文件的传递（503调度，各个模块之间的接口通信）

13. `IO流` **BIO、NIO、AIO有什么区别？**

> * BIO：Block IO 同步阻塞式IO，就是我们平常使用的传统IO，它的特点是模式简单实用方便，并发处理能力低
> * NIO：New IO同步非阻塞IO，是传统IO的升级，客户端和服务端通过Channel（通道）通讯，实现了多路复用
> * AIO：Asynchronous IO是NIO的升级，也叫NIO2，实现了异步非阻塞IO，异步IO的操作基于事件和回调机制
>
> ##### TODO：了解NIO实现原理，待补充

14. `文件` **File的常用方法有哪些？**

> * exists：是否存在
> * delete：删除
> * mkdir：创建文件夹
> * 获取文件名，文件路径等...

15. `内部类` **内部类有什么用？**

> 内部类可以有多个实例，每个实例都有自己的状态信息，并且与其他外围对象的信息相互独立。在当儿外围类当中，可以让多个内部类以不同的方式实现同一接口，或者继承同一个类。创建内部类对象的时刻不依赖与外部类对象的创建。内部类并没有令人疑惑的"is-a"关系，他就像一个独立的实体。此外，内部类提供了更好的封装，除了该外围类，其他类都不能访问。
>
> ##### 实际应用
>
> * 单例模式可以通过静态内部类的方式实现线程安全
> * JDK源码中的HashMap的Node类（源码中经常出现）

16. `克隆`  **clone()是哪个类的方法？**

> clone是Object自带的七个方法之一，是native方法，对象想要重写克隆方法需实现Cloneable接口（只是一个标志性接口）

17. `克隆` `设计模式` `原型模式` `对象拷贝` **深拷贝和浅拷贝**

> * 浅拷贝：被复制对象的所有变量都含有与原来对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。换言之，浅拷贝仅仅复制所考虑的对象，而不是复制他所引用的对象。
> * 深拷贝：被复制对象的所有变量都含有与原来的对象相同的值，而那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象，换言之，深拷贝吧要复制的对象所引用的对象都复制一遍

18. `java关键字` **static都有哪些用法？**

> * 修饰静态变量
> * 修饰静态方法
> * 修饰静态代码块，多用于初始化操作
> * 修饰内部类

19. `继承` **父类的静态方法能否被子类重写？**

> 不能，重写只适用于实例方法，不能用于静态方法，而子类当中含有和父类相同签名的静态方法，我们一般称之为隐藏

20. `对象` **什么是不可变对象？好处是什么?**

> 不可变对象指对象一旦被创建，状态就不能再改变，任何修改都会创建一个新的对象，如String、Integer及其他包装类，不可变对象最大的好处是线程安全。

21. `静态` `语法特性` 静态变量和实例变量的区别？

> 静态变量存储在方法区，属于类所有。实例变量存储在堆当中，其引用存在当前线程栈。需要注意的是从JDK1.8开始用于实现方法区的PermSpace被MetaSpace取代了。

22. `对象` **java创建对象的几种方式**

> * 通过new关键字调用构造方法进行创建
> * 通过反射进行创建
> * 采用clone机制
> * 通过序列化创建

23. `面向对象` **面向对象的三个特征？**

> * 继承：extends
> * 封装：访问修饰符
> * 多态：implments

24. `面向对象` `多态` **JVM是如何实现多态的**

> 动态绑定技术（dynamic binding），执行期间判断所引用对象的实际类型，根据实际类型调用对应的方法

25. `面向对象` `接口` **接口的意义**

> * 规范
> * 扩展
> * 回调

26. `抽象类` **抽象类的意义**

> * 为其他子类提供一个公共的类型
> * 封装子类中重复定义的内容
> * 定义抽象方法，子类虽然有不同的实现，但是定义是一致的

27. `面向对象` `多态` **Java多态**

> 对象的多态：父类或者接口的引用指向其子类的对象
>
> 实质：多态实际上是自动类型提升，即向上转型。向上转型为了提高提高扩展性并限制特有方法，向下转型为了使用特定方法；对于转型都是子类对象做着类型的变化

28. `面向对象` `多态` `方法重写` `方法重载`  **方法的重写和重载**

> 区别：
>
> | 区别点   | 重载方法OverLoading | 重写方法OverRiding                               |
> | -------- | ------------------- | ------------------------------------------------ |
> | 参数列表 | 必须修改            | 不能修改                                         |
> | 返回类型 | 可以修改            | 不能修改                                         |
> | 异常     | 可以修改            | 可以减少或者删除，但是不能抛出新的或者更广的异常 |
> | 访问     | 可以修改            | 一定不能做更严格的限制，可以降低限制             |
> | 使用范围 | 在一个类中          | 在子类中                                         |
> | 多态类别 | 编译时多态          | 运行时多态                                       |
>
> ##### 编译时多态与运行时多态
>
> * 编译时多态：发生在方法重载的时候，在类加载的时候会加载两个方法的版本。这个过程是在编译期就是确定的，这个时候我们通过不同参数调用相同函数名的时候就会返回不同的结果。
> * 运行时多态发生在继承的时候，父类有个方法，子类重写了父类的方法。这时候由父类对象指向子类的实例的时候，就会调用子类的方法。

### Java Thread

------

1. `并发` `并行`并发和并行有什么区别？

> * 并行是指两个或者多个事件在同一时刻发生；而并发是指两个或多个事件在同一时间间隔发生
> * 并行是在不同实体上的多个事件，并发是在同一实体上的多个事件
>
> 所以并发编程的目标是充分的利用处理器的每一个核，以达到最高的处理性能

2. `线程` `进程` 线程和进程的区别？

> 简而言之，进程是程序运行和资源分配的基本单位，一个程序至少有一个进程。一个进程至少有一个线程。进程在执行过程中拥有独立的内存单元，而多个线程贡献内存资源，减少切换次数，从而效率更高。线程是进程的一个实体，是cpu调度和分派的基本单位，是比程序更小的能独立运行的基本单位。同一进程中的多个线程之间可以并发执行。

3. `守护线程` 守护线程是什么？

> 守护线程（Daemon Thread），是个服务线程，准确地来说就是服务其他的线程

4. `线程` `线程创建` 创建线程有哪几种方式？

> 1. 继承Thread类，重写run方法（因为java的单继承机制，不推荐）
> 2. 实现Runnable接口，实现run方法
> 3. 实现Callable接口，实现call方法，通过FutureTask创建并启动新线程
> 4. 通过线程池创建线程

5. `Runnable` `Callable` Runnable和Callable二者区别？

> * Runnable的线程执行体返回值是void，而Callable的线程执行体是有返回值的，和Future、FutureTask配合可以用来获取异步执行的结果
> * Callable接口call方法允许将异常向上抛出，也可以直接在内部处理，而Runnable接口实现类中的run方法的异常必须在内部处理掉，不能向上抛出

6. `线程状态`线程有哪些状态？

> ```java
> public enum State {
>         /**
>          * 创建状态，尚未启动的线程的线程状态
>          */
>         NEW,
> 
>         /**
>          * 运行/就绪状态，一个处于运行状态的线程正在JVM中执行；也有可能正在等待获取CPU分配资源
>          */
>         RUNNABLE,
> 
>         /**
>          * 阻塞状态，等待锁资源而阻塞的线程状态，处于阻塞状态的线程正在等待其他线程释放锁，从而获取资源。或者在调用Object.wait()之后进入一个同步的方法/块
>          */
>         BLOCKED,
> 
>         /**
>          * 等待状态，由于调用了以下方法之一，线程处于等待状态：
>          * Object.wait with no timeout
> 		 * Thread.join with no timeout
>          * LockSupport.park
>          * 处于等待状态的线程正在等待另一个线程执行特定的操作。例如，在一个对象上调用了Object.wait()的线程正在等待另一个线程在该对象上调用Object.notify()或者Object.notifyall()。调用Thread.join()的线程正在等待指定线程终止。
>          */
>         WAITING,
> 
>         /**
>          * 定时等待状态，由于调用了下列方法中的一个，并且指定了正在等待的时间，线程处于定时等待状态：
>          * Thread.sleep
>          * Object.wait with timeout
>          * Thread.join with timeout
>          * LockSupport.parkNanos
>          * LockSupport.parkUntil
>          */
>         TIMED_WAITING,
> 
>     	/**
>     	 * 终止状态，线程已经执行完
>     	 */
>         TERMINATED;
> ```
>
> ![线程状态转换图](https://img-blog.csdn.net/20180512102914671?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NoaTJodWFuZw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

7. 
